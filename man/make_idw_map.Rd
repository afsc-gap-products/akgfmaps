% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/make_idw_map.R
\name{make_idw_map}
\alias{make_idw_map}
\title{Make IDW maps of CPUE for the EBS/NBS}
\usage{
make_idw_map(
  x = NA,
  COMMON_NAME = NA,
  LATITUDE = NA,
  LONGITUDE = NA,
  CPUE_KGHA = NA,
  region = "bs.south",
  extrap.box = NULL,
  extrapolation.grid.type = "stars",
  set.breaks = "jenks",
  grid.cell = c(5000, 5000),
  in.crs = "+proj=longlat",
  out.crs = "EPSG:3338",
  key.title = "auto",
  key.title.units = "CPUE (kg/ha)",
  log.transform = FALSE,
  idw.nmax = 4,
  use.survey.bathymetry = TRUE,
  return.continuous.grid = TRUE
)
}
\arguments{
\item{x}{Data frame which contains at minimum: CPUE, LATITUDE, and LONGITUDE. Can be passed as vectors instead (see below). Default value: \code{NA}}

\item{COMMON_NAME}{Common name}

\item{LATITUDE}{Latitude (degrees north)}

\item{LONGITUDE}{Longitude (degrees east; Western hemisphere is negative)}

\item{CPUE_KGHA}{Catch per unit effort in kilograms per hectare}

\item{region}{Character vector indicating which plotting region to use. Options: bs.south, bs.north, bs.all}

\item{extrap.box}{Optional. Vector specifying the dimensions of the extrapolation grid. Elements of the vector should be named to specify the minimum and maximum x and y values c(xmin, xmax, ymin, ymax). If not provided, the extrapolation area will be set to the extent of the survey.area bounding box with the output CRS.}

\item{extrapolation.grid.type}{Type of object to use for the extrapolation grid, default = "stars". "stars" = returns a 'stars' object; "sf" = sf object with layer masked to survey area extent and converted to collection of sf POLYGON and MULTIPOLYGON geometries; "sf.simple" = same as "sf", but with polygons vertices smoothed using rmapshaper::ms_simplify}

\item{set.breaks}{Either a numeric vector of breaks to use for plotting or a character vector indicating which classIntervals() algorithm to use for break selection. See Description for information about break selection.  Users are strongly encouraged to specify their own numeric vector of breaks based on the properties of their data.}

\item{grid.cell}{Numeric vector of length two specifying dimensions of grid cells for extrapolation grid, in units for the output CRS. Default = c(5000,5000) corresponds with 5x5 km for EPSG:3338}

\item{in.crs}{Character vector containing the coordinate reference system for projecting the extrapolation grid.}

\item{out.crs}{Character vector containing the coordinate reference system for projecting the extrapolation grid. The default is Alaska Albers Equal Area (EPSG:3338).}

\item{key.title}{Character vector which will appear in the legend above key.title.units. Default = "auto" tries to pull COMMON_NAME from input.}

\item{key.title.units}{Character vector which will appear in the legend below key title. Default = "CPUE (kg/ha)"}

\item{log.transform}{Character vector indicating whether CPUE values should be log-transformed for IDW. Default = FALSE.}

\item{idw.nmax}{Maximum number of adjacent stations to use for interpolation. Default = 8}

\item{use.survey.bathymetry}{Logical indicating if historical survey bathymetry should be used instead of continuous regional bathymetry. Default = TRUE}

\item{return.continuous.grid}{If TRUE, also returns an extrapolation grid on a continuous scale.}
}
\value{
Returns a list containing:
(1) plot: a ggplot IDW map;
(2) extrapolation.grid: the extrapolation grid with estimated values on a discrete scale as a 'stars' (when extrapolation.grid.type is "stars") or 'sf' (when extrapolation.grid.type is "sf" or "sf.simple") object;
(3) continuous.grid: extrapolation grid with estimates on a continuous scale;
(4) region: the region;
(5) n.breaks: the number of level breaks;
(6) key.title: title for the legend;
(7) crs: coordinate reference system as a PROJ6 (WKT2:2019) string;
}
\description{
This function can be used to make inverse-distance-weighted plots for the eastern Bering Sea and northern Bering Sea
}
\details{
This function include an argument for algorithmic break selection using the `set.breaks` argument. However, algorithmic break selection is provided for convenience purposes and **users are strongly encouraged to select their own breaks based on the properties of their data**. No single algorithm in the package can be expected to perform well in all cases. See ?classInt::classIntervals for a algorithmic break selection method options.
}
\author{
Sean Rohan \email{sean.rohan@noaa.gov}
}
